# Lab2 常量表达式

> 编译原理第二次实验

## 实验内容

- 本次实验包括两个部分，编译器需要在 lab 1 的基础上支持以下两个功能：
    - 实现正号、负号
    - 实现四则运算及模运算
    
    

## 实现思路

上次实验结尾说的深拷贝`lexer`然后根据`lexer`副本来输出token，汇总成`IR`的方法再次被抛弃了。。

之前那么做是因为lexer吐出得的token带有行号，可以灵活确定何时换行。但细想其实就会发现即使确定了怎么换行也没精力解决缩进~~(没能力)~~而且`IR`其实不在意换不换行，即使都是一行解释器也能处理，于是就选择用`yacc`的`result`，具体我还是选择以列表形式，尽量避免嵌套，最后在输出函数里一个`for`循环输出即可

当然还是稍微画蛇添足了一下，~~实在不能接受我的IR是一整行~~，我选择遇到`;`,`{`,`}`时将代码换行。

于是我的`parser`大概变成了这样：
```python
def p_Parser_init(p):
    ''' CompUnit : FuncDef '''
    p[0] = ['FuncDef', p[1]]
    
def p_FuncDef(p):
    ''' FuncDef : FuncType Ident LPar RPar Block'''
    p[0] = [p[1], p[2], p[3], p[4]] + p[5]

#...
```
以`p_`开头的函数都是`PLY.yacc`可以识别的语法分析函数，末尾的等式可以建立起语法左右的关系，然后默认返回`p[0]`到出现这个非终结符的地方。对于算术表达式，我选择尽可能保持字符串格式输入到`Stmt`中，然后通过`eval()`函数获取表达式的值。


## 问题

一共遇到了两个需要特殊考虑的点

1. 因为实验要求除法默认整除，而如果直接将输入的`/`交给`eval()`函数的话，那么将是一个浮点数计算。
对于表达式`2 / 3`，实验要求输出应该是0，而`eval()`返回值是0.666...
2. 第二个问题是取余运算，python默认的取余和c的取余有很大的差别：c取余结果正负只和被除数的正负有关，~~而python的我也没细查，反正bug了一个点肯定有区别，确信.jpg~~

对于以上两个问题，解决办法都是一样的，即：对文法做局部的处理，遇到对应的运算符时，将部分表达式摘出来提前处理，得到结果后传承字符串传递给调用者。

解决方法如下：
1. 对于取余运算，使用前后两个表达式的绝对值做取余运算，最后根据被除数的正负来决定结果的正负。
2. 对于除法，只需将对应位置的符号替换成python识别的整除`//`，一并交由顶层的`eval()`函数计算即可。
```python

def p_MulExp(p):
    ''' MulExp : UnaryExp 
               | MulExp Div UnaryExp
               | MulExp Mult UnaryExp
               | MulExp Mod UnaryExp'''
    if len(p) == 2:
        p[0] = str(p[1])
    elif p[2] == '/':
        p[0] = p[1] + ' // ' + p[3]
    elif p[2] == '%':
        if eval(p[1]) < 0: 
            p[0] = str(- (abs(eval(p[1]) % abs(eval(p[3])))))
        else:
            p[0] = str( (abs(eval(p[1]) % abs(eval(p[3])))))
    else: 
        p[0] = p[1] + ' ' + p[2] + ' ' + p[3]
```

